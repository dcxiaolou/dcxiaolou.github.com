<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[仿京东商城项目之商品全文搜索（五）]]></title>
    <url>%2F2019%2F10%2F23%2F%E4%BB%BF%E4%BA%AC%E4%B8%9C%E5%95%86%E5%9F%8E%E9%A1%B9%E7%9B%AE%E4%B9%8B%E5%95%86%E5%93%81%E5%85%A8%E6%96%87%E6%90%9C%E7%B4%A2%EF%BC%88%E4%BA%94%EF%BC%89%2F</url>
    <content type="text"><![CDATA[搜索什么是搜索， 计算机根据用户输入的关键词进行匹配，从已有的数据库中摘录出相关的记录反馈给用户。 常见的全网搜索引擎，像百度、谷歌这样的。但是除此以外，搜索技术在垂直领域也有广泛的使用，比如淘宝、京东搜索商品，万芳、知网搜索期刊，csdn中搜索问题贴。也都是基于海量数据的搜索。 如何处理搜索用传统关系性数据库弊端： 1、 对于传统的关系性数据库对于关键词的查询，只能逐字逐行的匹配，性能非常差。 2、匹配方式不合理，比如搜索“小米手机” ，如果用like进行匹配， 根本匹配不到。但是考虑使用者的用户体验的话，除了完全匹配的记录，还应该显示一部分近似匹配的记录，至少应该匹配到“手机”。 用专业全文索引全文搜索引擎目前主流的索引技术就是倒排索引的方式。 传统的保存数据的方式都是 ​ 记录→单词 而倒排索引的保存数据的方式是 单词→记录 那么搜索引擎是如何能将两者匹配上的呢？ 基于分词技术构建倒排索引 首先每个记录保存数据时，都不会直接存入数据库。系统先会对数据进行分词，然后以倒排索引结构保存。然后等到用户搜索的时候，会把搜索的关键词也进行分词。而且全文索引通常还会根据匹配程度进行打分 全文检索工具elasticsearchlucene与elasticsearchlucene能够处理分词，构建倒排索引，等等，但lucene不是搜索引擎。lucene只是一个提供全文搜索功能类库的核心工具包，而真正使用它还需要一个完善的服务框架搭建起来的应用。 好比lucene是类似于jdk，而搜索引擎软件就是tomcat的。 目前市面上流行的搜索引擎软件，主流的就两款，elasticsearch和solr,这两款都是基于lucene的搭建的，可以独立部署启动的搜索引擎服务软件。由于内核相同，所以两者除了服务器安装、部署、管理、集群以外，对于数据的操作，修改、添加、保存、查询等等都十分类似。就好像都是支持sql语言的两种数据库软件。只要学会其中一个另一个很容易上手。 从实际企业使用情况来看，elasticSearch的市场份额逐步在取代solr，国内百度、京东、新浪都是基于elasticSearch实现的搜索功能。国外就更多了 像维基百科、GitHub、Stack Overflow等等也都是基于ES的 elasticSearch的使用场景 为用户提供按关键字查询的全文搜索功能。 著名的ELK框架(ElasticSearch,Logstash,Kibana)，实现企业海量日志的处理分析的解决方案。大数据领域的重要一份子。 elasticsearch的基本概念 名称 说明 cluster 整个elasticsearch 默认就是集群状态，整个集群是一份完整、互备的数据。 node 集群中的一个节点，一般一个进程就是一个node shard 分片，即使是一个节点中的数据也会通过hash算法，分成多个片存放，默认是5片。 Index(库) 相当于rdbms的database, 对于用户来说是一个逻辑数据库，虽然物理上会被分多个shard存放，也可能存放在多个node中。 Type(表) 类似于rdbms的table Document(一条数据) 类似于rdbms的 row Field(字段) 相当于字段、属性 es中保存的数据结构1234567891011public class Movie &#123; String id; String name; Double doubanScore; List&lt;Actor&gt; actorList;&#125;public class Actor&#123; String id; String name;&#125; 这两个对象如果放在关系型数据库保存，会被拆成2张表，但是elasticsearch是用一个json来表示一个document。 所以保存到es中应该是： 12345678910&#123; “id”:”1”, “name”:”operation red sea”, “doubanScore”:”8.5”, “actorList”:[ &#123;“id”:”1”,”name”:”zhangyi”&#125;, &#123;“id”:”2”,”name”:”haiqing”&#125;, &#123;“id”:”3”,”name”:”zhanghanyu”&#125; ]&#125; 关于mapping的类型之前说type可以理解为table，那每个字段的数据类型是如何定义的呢 查看mapping 1GET movie_index/_mapping/movie 实际上每个type中的字段是什么数据类型，由mapping定义。 但是如果没有设定mapping系统会自动，根据一条数据的格式来推断出应该的数据格式。 true/false → boolean 1020 → long 20.1 → double “2018-02-01” → date “hello world” → text +keyword 默认只有text会进行分词，keyword是不会分词的字符串。 mapping除了自动定义，还可以手动定义，但是只能对新加的、没有数据的字段进行定义。一旦有了数据就无法再做修改了。 注意：虽然每个Field的数据放在不同的type下,但是同一个名字的Field在一个index下只能有一种mapping定义。 中文分词elasticsearch本身自带的中文分词，就是单纯把中文一个字一个字的分开，根本没有词汇的概念。但是实际应用中，用户都是以词汇为条件，进行查询匹配的，如果能够把文章以词汇为单位切分开，那么与用户的查询条件能够更贴切的匹配上，查询速度也更加快速。 分词器下载网址：https://github.com/medcl/elasticsearch-analysis-ik 安装下载好的zip包，解压后放到 elasticsearch安装目录下的plugins/ik中 然后重启es 5.4.2测试使用使用默认 1234GET movie_index/_analyze&#123; &quot;text&quot;: &quot;我是中国人&quot;&#125; 使用分词器 12345GET movie_index/_analyze&#123; &quot;analyzer&quot;: &quot;ik_smart&quot;, &quot;text&quot;: &quot;我是中国人&quot;&#125; 另外一个分词器 ​ ik_max_word 12345GET movie_index/_analyze&#123; &quot;analyzer&quot;: &quot;ik_max_word&quot;, &quot;text&quot;: &quot;我是中国人&quot;&#125; 能够看出不同的分词器，分词有明显的区别，所以以后定义一个type不能再使用默认的mapping了，要手工建立mapping, 因为要选择分词器。 基于中文分词搭建索引1、建立mapping 1234567891011121314151617181920212223242526272829PUT movie_chn&#123; &quot;mappings&quot;: &#123; &quot;movie&quot;:&#123; &quot;properties&quot;: &#123; &quot;id&quot;:&#123; &quot;type&quot;: &quot;long&quot; &#125;, &quot;name&quot;:&#123; &quot;type&quot;: &quot;text&quot; , &quot;analyzer&quot;: &quot;ik_smart&quot; &#125;, &quot;doubanScore&quot;:&#123; &quot;type&quot;: &quot;double&quot; &#125;, &quot;actorList&quot;:&#123; &quot;properties&quot;: &#123; &quot;id&quot;:&#123; &quot;type&quot;:&quot;long&quot; &#125;, &quot;name&quot;:&#123; &quot;type&quot;:&quot;keyword&quot; &#125; &#125; &#125; &#125; &#125; &#125;&#125; 插入数据 1234567891011121314151617181920212223242526272829PUT movie_chn&#123; &quot;mappings&quot;: &#123; &quot;movie&quot;:&#123; &quot;properties&quot;: &#123; &quot;id&quot;:&#123; &quot;type&quot;: &quot;long&quot; &#125;, &quot;name&quot;:&#123; &quot;type&quot;: &quot;text&quot; , &quot;analyzer&quot;: &quot;ik_smart&quot; &#125;, &quot;doubanScore&quot;:&#123; &quot;type&quot;: &quot;double&quot; &#125;, &quot;actorList&quot;:&#123; &quot;properties&quot;: &#123; &quot;id&quot;:&#123; &quot;type&quot;:&quot;long&quot; &#125;, &quot;name&quot;:&#123; &quot;type&quot;:&quot;keyword&quot; &#125; &#125; &#125; &#125; &#125; &#125;&#125; 查询测试 1234567891011121314151617GET /movie_chn/movie/_search&#123; &quot;query&quot;: &#123; &quot;match&quot;: &#123; &quot;name&quot;: &quot;红海战役&quot; &#125; &#125;&#125;GET /movie_chn/movie/_search&#123; &quot;query&quot;: &#123; &quot;term&quot;: &#123; &quot;actorList.name&quot;: &quot;张译&quot; &#125; &#125;&#125; 整合es客户端到Java程序中搭建模块pom.xml 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.dcxiaolou.tinyjd&lt;/groupId&gt; &lt;artifactId&gt;tinyjd-list-service&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;tinyjd-list-service&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;parent&gt; &lt;groupId&gt;com.dcxiaolou.tinyjd&lt;/groupId&gt; &lt;artifactId&gt;tinyjd-parent&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.dcxiaolou.tinyjd&lt;/groupId&gt; &lt;artifactId&gt;tinyjd-interface&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.dcxiaolou.tinyjd&lt;/groupId&gt; &lt;artifactId&gt;tinyjd-service-util&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 关于es 的java 客户端的选择目前市面上有两类客户端 一类是TransportClient 为代表的ES原生客户端，不能执行原生dsl语句必须使用它的Java api方法。 另外一种是以Rest Api为主的missing client，最典型的就是jest。 这种客户端可以直接使用dsl语句拼成的字符串，直接传给服务端，然后返回json字符串再解析。 两种方式各有优劣，但是最近elasticsearch官网，宣布计划在7.0以后的版本中废除TransportClient。以RestClient为主。所以在官方的RestClient 基础上，进行了简单包装的Jest客户端，就成了首选，而且该客户端也与springboot完美集成。 导入Jest依赖12345678910111213141516171819&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-elasticsearch&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/io.searchbox/jest --&gt;&lt;dependency&gt; &lt;groupId&gt;io.searchbox&lt;/groupId&gt; &lt;artifactId&gt;jest&lt;/artifactId&gt; &lt;version&gt;5.3.3&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/net.java.dev.jna/jna --&gt;&lt;dependency&gt; &lt;groupId&gt;net.java.dev.jna&lt;/groupId&gt; &lt;artifactId&gt;jna&lt;/artifactId&gt; &lt;version&gt;4.5.1&lt;/version&gt;&lt;/dependency&gt; 在测试类中测试ESapplication.properties中加入 1spring.elasticsearch.jest.uris=http://192.168.67.163:9200 12@AutowiredJestClient jestClient; sku数据保存到ESes存储数据是以json格式保存的，那么如果一个java bean的结构刚好跟要求的json格式吻合，我们就可以直接把javaBean序列化为json保持到es中，所以我们要制作一个与es中json格式一致的javabean. 12345678910111213public static final String index_name_tinyjd="tinyjd";public static final String type_name_tinyjd="SkuInfo";public void saveSkuInfo(SkuLsInfo skuLsInfo)&#123; Index index= new Index.Builder(skuLsInfo).index(index_name_tinyjd).type(type_name_tinyjd).id(skuLsInfo.getId()).build(); try &#123; jestClient.execute(index); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125; 电商的搜索列表功能功能简介入口： 两个 首页的分类和搜索栏 根据业务搭建数据结构这时我们要思考三个问题： 哪些字段需要分词 我们用哪些字段进行过滤 哪些字段我们需要通过搜索显示出来 需要分词的字段 sku名称 sku描述 分词、定义分词器 有可能用于过滤的字段 平台属性、三级分类、价格 要索引 其他需要显示的字段 skuId 图片路径 不索引 根据以上制定出如下结构： 1234567891011121314151617181920212223242526272829303132333435363738PUT gmall&#123; "mappings": &#123; "SkuInfo":&#123; "properties": &#123; "id":&#123; "type": "keyword", "index": false &#125;, "price":&#123; "type": "double" &#125;, "skuName":&#123; "type": "text", "analyzer": "ik_max_word" &#125;, "skuDesc":&#123; "type": "text", "analyzer": "ik_smart" &#125;, "catalog3Id":&#123; "type": "keyword" &#125;, "skuDefaultImg":&#123; "type": "keyword", "index": false &#125;, "skuAttrValueList":&#123; "properties": &#123; "valueId":&#123; "type":"keyword" &#125; &#125; &#125; &#125; &#125; &#125;&#125; 查询数据的后台方法分析首先先观察功能页面，咱们一共要用什么查询条件，查询出什么数据？ 查询条件： 关键字 可以通过分类进入列表页面 属性值 分页页码 查询结果： sku的列表(关键字高亮显示) 这些sku涉及了哪些属性和属性值 命中个数，用于分页 编写DSL语句：123456789101112131415161718192021222324252627GET gmall/SkuInfo/_search&#123; &quot;query&quot;: &#123; &quot;bool&quot;: &#123; &quot;filter&quot;: [ &#123;&quot;terms&quot;:&#123; &quot;skuAttrValueList.valueId&quot;: [&quot;46&quot;,&quot;45&quot;]&#125;&#125;, &#123;&quot;term&quot;:&#123;&quot;catalog3Id&quot;:&quot;61&quot;&#125;&#125; ], &quot;must&quot;: &#123; &quot;match&quot;: &#123; &quot;skuName&quot;: &quot;128&quot; &#125; &#125; &#125; &#125; , &quot;highlight&quot;: &#123; &quot;fields&quot;: &#123;&quot;skuName&quot;:&#123;&#125;&#125; &#125;, &quot;from&quot;: 3, &quot;size&quot;: 1, &quot;sort&quot;:&#123;&quot;hotScore&quot;:&#123;&quot;order&quot;:&quot;desc&quot;&#125;&#125;, &quot;aggs&quot;: &#123; &quot;groupby_attr&quot;: &#123; &quot;terms&quot;: &#123; &quot;field&quot;: &quot;skuAttrValueList.valueId&quot; &#125; &#125; &#125;&#125; 构造查询DSL查询的过程很简单，但是要构造查询的query这个字符串有点麻烦，主要是这个Json串中的数据都是动态的。要拼接这个字符串，需要各种循环判断，处理标点符号等等。操作麻烦，可读性差。 但是jest这个客户端包，提供了一组builder工具。这个工具可以比较方便的帮程序员组合复杂的查询Json。 123456789101112131415161718192021222324252627282930313233343536373839404142private String makeQueryStringForSearch(SkuLsParams skuLsParams)&#123; SearchSourceBuilder searchSourceBuilder=new SearchSourceBuilder(); BoolQueryBuilder boolQueryBuilder = QueryBuilders.boolQuery(); if(skuLsParams.getKeyword()!=null)&#123; MatchQueryBuilder matchQueryBuilder=new MatchQueryBuilder("skuName",skuLsParams.getKeyword()); boolQueryBuilder.must(matchQueryBuilder); HighlightBuilder highlightBuilder=new HighlightBuilder(); highlightBuilder.field("skuName"); highlightBuilder.preTags("&lt;span style='color:red'&gt;"); highlightBuilder.postTags("&lt;/span&gt;"); searchSourceBuilder.highlight(highlightBuilder); TermsBuilder groupby_attr = AggregationBuilders.terms("groupby_attr").field("skuAttrValueList.valueId"); searchSourceBuilder.aggregation(groupby_attr); &#125; if(skuLsParams.getCatalog3Id()!=null)&#123; QueryBuilder termQueryBuilder=new TermQueryBuilder("catalog3Id",skuLsParams.getCatalog3Id()); boolQueryBuilder.filter(termQueryBuilder); &#125; if(skuLsParams.getValueId()!=null&amp;&amp;skuLsParams.getValueId().length&gt;=0)&#123; for (int i = 0; i &lt; skuLsParams.getValueId().length; i++) &#123; String valueId = skuLsParams.getValueId()[i]; QueryBuilder termQueryBuilder=new TermsQueryBuilder("skuAttrValueList.valueId",valueId); boolQueryBuilder.filter(termQueryBuilder); &#125; &#125; searchSourceBuilder.query(boolQueryBuilder); int from =(skuLsParams.getPageNo()-1)*skuLsParams.getPageSize(); searchSourceBuilder.from(from); searchSourceBuilder.size(skuLsParams.getPageSize()); searchSourceBuilder.sort("hotScore",SortOrder.DESC); String query = searchSourceBuilder.toString(); System.err.println("query = " + query); return query;&#125; 处理返回值思路：所有的返回值其实都在这个searchResult中 1searchResult = jestClient.execute(search); 检索的页面创建gmall-list-web模块pom.xml 1234567891011121314151617181920&lt;parent&gt; &lt;groupId&gt;com.dcxiaolou.tinyjd&lt;/groupId&gt; &lt;artifactId&gt;tinyjd-parent&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;&lt;/parent&gt;&lt;dependencies&gt;&lt;dependency&gt; &lt;groupId&gt;com.dcxiaolou.tinyjd&lt;/groupId&gt; &lt;artifactId&gt;tinyjd-interface&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.dcxiaolou.tinyjd&lt;/groupId&gt; &lt;artifactId&gt;tinyjd-web-util&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;&lt;/dependency&gt;&lt;/dependencies&gt; 静态网页及资源文件拷贝静态文件到resources目录下，手工建立static和templates目录 application.properties12345server.port=8085spring.thymeleaf.cache=falsespring.thymeleaf.mode=LEGACYHTML5 sku列表功能首先是根据关键字、属性值、分类Id、页码查询sku列表。 页面html渲染123456789101112131415&lt;div style="width:215px" th:each="skuLsInfo:$&#123;skuLsInfoList&#125;" &gt; &lt;p class="da"&gt; &lt;a href="#" th:onclick="'javascript:item(\''+$&#123;skuLsInfo.id&#125;+'\')'"&gt; &lt;img th:src="$&#123;skuLsInfo.skuDefaultImg&#125;" src="img/57d0d400Nfd249af4.jpg" class="dim"&gt; &lt;/a&gt; &lt;/p&gt; &lt;p class="tab_R"&gt; &lt;span th:text="'￥'+$&#123;#numbers.formatDecimal(skuLsInfo.price,1,2)&#125;"&gt;¥5199.00&lt;/span&gt; &lt;/p&gt; &lt;a href="#" title="" th:onclick="'javascript:item(\''+$&#123;skuLsInfo.id&#125;+'\')'" class="tab_JE" th:utext="$&#123;skuLsInfo.skuName&#125;" &gt; Apple iPhone 7 Plus (A1661) 32G 黑色 移动联通电信4G手机 &lt;/a&gt; &lt;/div&gt; 要注意的是其中skuName中因为关键字标签所以必须要用utext否则标签会被转义。 搜索栏相关html12345678910111213141516171819&lt;!--搜索导航--&gt;&lt;div class="header_sous"&gt; &lt;div class="logo"&gt; &lt;a href="#"&gt;&lt;img src="/image/logo1.jpg" alt=""&gt;&lt;/a&gt; &lt;/div&gt; &lt;div class="header_form"&gt; &lt;input id="keyword" name="keyword" type="text" placeholder="手机" /&gt; &lt;a href="#" onclick="searchList()"&gt;搜索&lt;/a&gt; &lt;/div&gt; &lt;div class="header_ico"&gt; &lt;div class="header_gw"&gt; &lt;span&gt;&lt;a href="#"&gt;我的购物车&lt;/a&gt;&lt;/span&gt; &lt;img src="/image/settleup-@1x.png" /&gt; &lt;span&gt;0&lt;/span&gt; &lt;/div&gt; &lt;div class="header_ko"&gt; &lt;p&gt;购物车中还没有商品，赶紧选购吧！&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; js代码12345678function searchList()&#123; var keyword = $("#keyword").val(); window.location.href="/list.html?keyword="+keyword;&#125;function item(skuid) &#123; window.location.href="http://item.tinyjd.com/"+skuid+".html";&#125; 这时可以看到列表效果了。 页面功能—提供可供选择的属性列表思路：这个列表有两种情况 如果是通过首页的3级分类点击进入的，要按照分类Id查询对应的属性和属性值列表。 如果是直接用搜索栏输入文字进入的，要根据sku的查询结果涉及的属性值(好在我们已经通过es的聚合取出来了)，再去查询数据库把文字列表显示出来。 ListControllergetList方法中添加 123456789101112//根据查询的结果返回属性和属性值列表List&lt;BaseAttrInfo&gt; attrList=null;if(skuLsParams.getCatalog3Id()!=null)&#123; attrList = manageService.getAttrList(skuLsParams.getCatalog3Id());&#125;else &#123; List&lt;String&gt; attrValueIdList = skuLsResult.getAttrValueIdList(); if(attrValueIdList!=null&amp;&amp;attrValueIdList.size()&gt;0)&#123; attrList = manageService.getAttrList(attrValueIdList); &#125;&#125;model.addAttribute("attrList",attrList); 在ManageServiceImpl中增加方法123456@Overridepublic List&lt;BaseAttrInfo&gt; getAttrList(List&lt;String&gt; attrValueIdList) &#123; String attrValueIds = StringUtils.join(attrValueIdList.toArray(), ","); List&lt;BaseAttrInfo&gt; baseAttrInfoList = baseAttrInfoMapper.selectAttrInfoListByIds(attrValueIds); return baseAttrInfoList;&#125; BaseAttrInfoMapper.xml123456789101112131415161718192021222324&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE mapper SYSTEM "http://mybatis.org/dtd/mybatis-3-mapper.dtd" &gt;&lt;mapper namespace="com.atguigu.gmall.manage.mapper.BaseAttrInfoMapper"&gt; &lt;select id ="selectAttrInfoList" parameterType="long" resultMap="attrInfoMap"&gt; SELECT ba.id,ba.attr_name,ba.catalog3_id, bv.id value_id ,bv.value_name, bv.attr_id FROM base_attr_info ba INNER JOIN base_attr_value bv ON ba.id =bv.attr_id where ba.catalog3_id=#&#123;catalog3Id&#125; &lt;/select&gt; &lt;resultMap id="attrInfoMap" type="com.atguigu.gmall.bean.BaseAttrInfo" autoMapping="true"&gt; &lt;result property="id" column="id" &gt;&lt;/result&gt; &lt;collection property="attrValueList" ofType="com.atguigu.gmall.bean.BaseAttrValue" autoMapping="true"&gt; &lt;result property="id" column="value_id" &gt;&lt;/result&gt; &lt;/collection&gt; &lt;/resultMap&gt; &lt;select id ="selectAttrInfoListByIds" resultMap="attrInfoMap"&gt; SELECT ba.id,ba.attr_name,ba.catalog3_id, bv.id value_id ,bv.value_name, bv.attr_id FROM base_attr_info ba INNER JOIN base_attr_value bv ON ba.id =bv.attr_id where bv.id in ($&#123;attrValueIds&#125;) &lt;/select&gt;&lt;/mapper&gt; 注意这里面没有用#{}是因为attrValueIds 是两个数字用逗号分开的，所以不能整体套上单引，所以使用${} BaseAttrInfoMapper123456public interface BaseAttrInfoMapper extends Mapper&lt;BaseAttrInfo&gt; &#123; public List&lt;BaseAttrInfo&gt; selectAttrInfoList(long catalog3Id); public List&lt;BaseAttrInfo&gt; selectAttrInfoListByIds(@Param("attrValueIds") String attrValueIds);&#125; 此处必须要用@Param注解否则${ }无法识别。 点击属性值的链接getAttrList(List attrValueIdList)方法实现后，还有一个问题就是，点击属性时，要把上次查询的内容也带上，即带上历史参数。 123456789101112131415161718192021private String makeUrlParam(String keyword,String catalog3Id, String[] valueIds,String excludeValueId )&#123; String url=""; List&lt;String&gt; paramList=new ArrayList&lt;&gt;(); if(keyword!=null&amp;&amp;keyword.length()&gt;0)&#123; paramList.add("keyword="+keyword); &#125; if(catalog3Id!=null)&#123; paramList.add("catalog3Id="+catalog3Id); &#125; if(valueIds!=null) &#123; for (int i = 0; i &lt; valueIds.length; i++) &#123; String valueId = valueIds[i]; if (!excludeValueId.equals(valueId)) &#123; paramList.add("valueId=" + valueId) ; &#125; &#125; &#125; url = StringUtils.join(paramList, "&amp;"); return url;&#125; getList方法中增加 1234567//历史参数String[] valueIds=skuLsParams.getValueId();String catalog3Id = skuLsParams.getCatalog3Id();String keyword=skuLsParams.getKeyword();String urlParam = makeUrlParam(keyword,catalog3Id, valueIds, "");model.addAttribute("urlParam",urlParam); 生成属性列表的html部分12345678910111213141516171819&lt;div class="GM_selector"&gt; &lt;div class="title"&gt; &lt;h3&gt;&lt;em&gt;商品筛选&lt;/em&gt;&lt;/h3&gt; &lt;/div&gt; &lt;div class="GM_nav_logo"&gt; &lt;div class="GM_pre" th:each="attrInfo:$&#123;attrList&#125;"&gt; &lt;div class="sl_key"&gt; &lt;span th:text="$&#123;attrInfo.attrName&#125;+':'"&gt;属性：&lt;/span&gt; &lt;/div&gt; &lt;div class="sl_value"&gt; &lt;ul&gt; &lt;li th:each="attrValue:$&#123;attrInfo.attrValueList&#125;"&gt;&lt;a th:href="'/list.html?'+$&#123;urlParam&#125;+'&amp;valueId='+$&#123;attrValue.id&#125;" th:text="$&#123;attrValue.valueName&#125;"&gt;属性值&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 页面功能–面包屑面包屑导航是为了能够让用户清楚的知道当前页面的所在位置和筛选条件的功能。但是这个小的人性化功能却有点麻烦。 功能点： 点击某个属性值的时候对应的那行属性要消失掉不能再次选择。 列在上面的属性面包屑，要可以取消掉，恢复到没选择之前。 思路： 把本应显示的列表与用户已选择的属性值列表用循环交叉判断，如果匹配把本应显示的那个属性去掉。 已选择的属性值列表，要携带点击跳转的路径，这个路径参数就是咱们上边讲的那个“历史参数”，但是要把自己本身的属性值去掉。]]></content>
      <categories>
        <category>个人项目</category>
        <category>电商</category>
      </categories>
      <tags>
        <tag>个人项目</tag>
        <tag>电商</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[仿京东商城项目之商品详情页（四）]]></title>
    <url>%2F2019%2F10%2F22%2F%E4%BB%BF%E4%BA%AC%E4%B8%9C%E5%95%86%E5%9F%8E%E9%A1%B9%E7%9B%AE%E4%B9%8B%E5%95%86%E5%93%81%E8%AF%A6%E6%83%85%E9%A1%B5%EF%BC%88%E5%9B%9B%EF%BC%89%2F</url>
    <content type="text"><![CDATA[商品详情页业务介绍商品详情页，简单说就是以购物者的角度展现一个sku的详情信息。 这个页面不同于传统的crud的详情页，使用者并不是管理员，需要对信息进行查删改查，取而代之的是点击购买、放入购物车、切换颜色等等。 另外一个特点就是该页面的高访问量，虽然只是一个查询操作，但是由于频繁的访问所以我们必须对其性能进行最大程度的优化。 难点分析 光从功能角度上来说，并没有太多难点，唯一实现起来麻烦的就是用户对于不同销售属性的切换操作。 从性能角度来看，需要最大程度的提升页面的访问速度。 功能开发详情页功能，只增加一个web模块，后台调用商品管理的模块manage-service item-web模块负责前端的页面渲染和控制层(controller)。 pom.xml 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;com.dcxiaolou.tinyJD&lt;/groupId&gt; &lt;artifactId&gt;tinyjd-parent&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;groupId&gt;com.dcxiaolou.tinyJD&lt;/groupId&gt; &lt;artifactId&gt;tinyjd-item-web&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;tinyjd-item-web&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.dcxiaolou.tinyJD&lt;/groupId&gt; &lt;artifactId&gt;tinyjd-web-util&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.dcxiaolou.tinyJD&lt;/groupId&gt; &lt;artifactId&gt;tinyjd-api&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 搭建完成后。 首先导入前端页面 静态页资源全部拷贝到static目录中，如果没有该目录请手工创建 动态的html文件拷贝到templates目录中 编写Controller类（入口方法） application.properties 12345server.port=8084// 禁用thymeleaf缓存spring.thymeleaf.cache=false// 关闭thymeleaf的html5语法检查spring.thymeleaf.mode=LEGACYHTML5 把启动类TinyjdItemWebApplication提到和item平级的目录中。 1或者增加@ComponentScan(basePackages = &quot;com.atguigu.gmall&quot;) 然后启动服务、测试 可以看到商品详情页的静态页面。 后台实现在tinyjd-item-web模块中 增加ItemController tinyjd-manage-service中增加后台实现类 如何销售属性切换当前商品sku思路： 查出该商品的spu的所有销售属性和属性值 标识出本商品对应的销售属性 点击其他销售属性值的组合，跳转到另外的sku页面 1234567891011121314151617181920212223242526SELECT sa.id, sa.spu_id, sa.sale_attr_name, sa.sale_attr_id, sv.id sale_attr_value_id, sv.sale_attr_value_name, skv.sku_id, if(skv.sku_id is not null,1,0) as isCheckFROM spu_sale_attr sa inner JOIN spu_sale_attr_value sv on sa.sale_attr_id = sv.sale_attr_id and sa.spu_id = sv.spu_id and sa.spu_id = 25LEFT JOIN sku_sale_attr_value skv on skv.sale_attr_id = sa.sale_attr_id and skv.sale_attr_value_id = sv.id and skv.sku_id = 47ORDER BY sv.sale_attr_idSELECT skv.*FROM sku_sale_attr_value skvINNER JOIN sku_info sk ON skv.sku_id =sk.id and sk.spu_id=25ORDER BY skv.sku_id , skv.sale_attr_idselect skv.* from sku_sale_attr_value skv , sku_info sku where skv.sku_id =sku.id and sku.spu_id=25 ORDER BY sku.id , skv.sale_attr_id 查询出sku对应spu的销售属性第1、2条通过此sql实现 12345678910SELECT sa.id ,sa.spu_id, sa.sale_attr_name,sa.sale_attr_id, sv.id sale_attr_value_id, sv.sale_attr_value_name, skv.sku_id, IF(skv.sku_id IS NOT NULL,1,0) is_check FROM spu_sale_attr sa INNER JOIN spu_sale_attr_value sv ON sa.spu_id=sv.spu_id AND sa.sale_attr_id=sv.sale_attr_id LEFT JOIN sku_sale_attr_value skv ON skv.sale_attr_id= sa.sale_attr_id AND skv.sale_attr_value_id=sv.id AND skv.sku_id=10 WHERE sa.spu_id=24ORDER BY sv.sale_attr_id,sv.id 此sql列出所有该spu的销售属性和属性值，并关联某skuid如果能关联上is_check设为1，否则设为0。 页面开发部分 12345678910&lt;div class="box-attr-2 clear" th:each="spuSaleAttr:$&#123;spuSaleAttrListCheckBySku&#125;"&gt; &lt;dl&gt; &lt;dt th:text="$&#123;spuSaleAttr.saleAttrName&#125;"&gt;选择属性&lt;/dt&gt; &lt;dd th:class="($&#123;saleAttrValue.isCheck&#125;=='1')?'redborder':''" th:each="saleAttrValue:$&#123;spuSaleAttr.spuSaleAttrValueList&#125;"&gt; &lt;div th:value="$&#123;saleAttrValue.id&#125;" th:text="$&#123;saleAttrValue.saleAttrValueName&#125;"&gt; 属性值 &lt;/div&gt; &lt;/dd&gt; &lt;/dl&gt;&lt;/div&gt; 其中th:class的设置，redborder是一个自定义的样式类，主要是边框设红。如果isCheck=1标识当前这个sku的所拥有的属性值，所以锁定为红边框。 点击其他销售属性值的组合，跳转到另外的sku页面实现思路： 从页面中获得得所有选中的销售属性进行组合比如： “属性值1|属性值2|属性值3” 用这个字符串匹配一个对照表，来获得skuId。并进行跳转，或者告知无货。 后台要生成一个“属性值1|属性值2|属性值3：skuId”的一个json串以提供页面进行匹配。如 需要从后台数据库查询出该spu下的所有skuId和属性值关联关系。然后加工成如上的Json串。 实现： skuSaleAttrValueMapper.xml中sql 1234567891011121314&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE mapper SYSTEM "http://mybatis.org/dtd/mybatis-3-mapper.dtd" &gt;&lt;mapper namespace="com.dcxiaolou.tinyjd.manage.mapper.SkuSaleAttrValueMapper"&gt; &lt;select id ="selectSkuSaleAttrValueListBySpu" parameterType="long" resultMap="skuSaleAttrValueMap"&gt; SELECT skv.* FROM sku_sale_attr_value skv INNER JOIN sku_info sk ON skv.sku_id =sk.id where sk.spu_id=#&#123;spuId&#125; ORDER BY skv.sku_id , skv.sale_attr_id &lt;/select&gt; &lt;resultMap id="skuSaleAttrValueMap" type="com.dcxiaolou.tinyjd.bean.SkuSaleAttrValue" autoMapping="true"&gt; &lt;result property="id" column="id" &gt;&lt;/result&gt; &lt;/resultMap&gt;&lt;/mapper&gt; 要注意排序，方便后面整理。 实现类很简单： 1234public List&lt;SkuSaleAttrValue&gt; getSkuSaleAttrValueListBySpu(String spuId)&#123; List&lt;SkuSaleAttrValue&gt; skuSaleAttrValueList = skuSaleAttrValueMapper.selectSkuSaleAttrValueListBySpu(Long.parseLong(spuId)); return skuSaleAttrValueList;&#125; 难点是整理成咱们要求的json串，这个写在controller类。 123456789101112131415161718192021222324252627List&lt;SkuSaleAttrValue&gt; skuSaleAttrValueListBySpu = manageService.getSkuSaleAttrValueListBySpu(skuInfo.getSpuId());//把列表变换成 valueid1|valueid2|valueid3 ：skuId 的 哈希表 用于在页面中定位查询String valueIdsKey="";Map&lt;String,String&gt; valuesSkuMap=new HashMap&lt;&gt;();for (int i = 0; i &lt; skuSaleAttrValueListBySpu.size(); i++) &#123; SkuSaleAttrValue skuSaleAttrValue = skuSaleAttrValueListBySpu.get(i); if(valueIdsKey.length()!=0)&#123; valueIdsKey= valueIdsKey+"|"; &#125; valueIdsKey=valueIdsKey+skuSaleAttrValue.getSaleAttrValueId(); if((i+1)== skuSaleAttrValueListBySpu.size()||!skuSaleAttrValue.getSkuId().equals(skuSaleAttrValueListBySpu.get(i+1).getSkuId()) )&#123; valuesSkuMap.put(valueIdsKey,skuSaleAttrValue.getSkuId()); valueIdsKey=""; &#125;&#125;//把map变成json串String valuesSkuJson = JSON.toJSONString(valuesSkuMap);model.addAttribute("valuesSkuJson",valuesSkuJson); 在item中增加隐藏域 12&lt;input id="valuesSku" type="hidden" th:value= " $&#123;valuesSkuJson&#125;" /&gt;&lt;input id="skuId" type="hidden" th:value= " $&#123;skuInfo.id&#125;" /&gt; valuesSku存储属性值与skuid的对照json skuId存放当前商品的skuId 修改页面的js 12345//红边框$(".box-attr-2 dd").click(function() &#123; $(this).addClass("redborder").siblings("dd").removeClass("redborder"); switchSkuId();&#125;) 增加点击销售属性时触发切换sku方法 12345678910111213141516171819202122232425262728293031323334function switchSkuId() &#123;var redborderDivs = $(".redborder div");var valueIdkeys="";for(i=0;i&lt;redborderDivs.length;i++)&#123; var redborderDiv= redborderDivs.eq(i); var attrValueId = redborderDiv.attr("value"); if(i&gt;0)&#123; valueIdkeys+="|"; &#125; valueIdkeys+=attrValueId;&#125;console.log("valueIdkeys:"+valueIdkeys); var valueIdSkuJson= $("#valueIdSkuJson").val(); console.log("valueIdSkuJson:"+valueIdSkuJson); var skuSelfId= $("#skuId").val(); var valueIdSku = JSON.parse(valueIdSkuJson); var skuIdTarget = valueIdSku[valueIdkeys]; if(!skuIdTarget)&#123; $("#cartBtn").attr("class","box-btns-two-off"); $("#cartBtn").attr("canClick",'0'); $("#cartBtn").css("cursor",'not-allowed') ;&#125;else&#123; if(skuSelfId!=skuIdTarget)&#123; window.location.href="/"+skuIdTarget+".html"; &#125;else&#123; $("#cartBtn").attr("class","box-btns-two"); $("#cartBtn").attr("canClick",'1'); $("#cartBtn").css("cursor",'pointer') ; &#125; &#125; &#125;&#125; 最后测试： 性能优化思路：​ 虽然实现了页面需要的功能，但是考虑到该页面是被用户高频访问的，所以性能必须进行尽可能的优化。 一般一个系统最大的性能瓶颈，就是数据库的io操作。从数据库入手也是调优性价比最高的切入点。 一般分为两个层面，一是提高数据库sql本身的性能，二是尽量避免直接查询数据库。 提高数据库本身的性能首先是优化sql，包括：使用索引，减少不必要的大表关联次数，控制查询字段的行数和列数。另外当数据量巨大是可以考虑分库分表，以减轻单点压力。 另外一个层面：尽量避免直接查询数据库。 解决办法就是：缓存 缓存可以理解是数据库的一道保护伞，任何请求只要能在缓存中命中，都不会直接访问数据库。而缓存的处理性能是数据库10-100倍。 这里使用Redis作为缓存系统进行优化。 整合redis到工程中由于redis作为缓存数据库，要被多个项目使用，所以要制作一个通用的工具类，方便工程中的各个模块使用。 而主要使用redis的模块，都是后台服务的模块，xxx-service工程。这里把redis的工具类放到service-util模块中，这样所有的后台服务模块都可以使用redis。 首先引入依赖包 123456&lt;!-- https://mvnrepository.com/artifact/redis.clients/jedis --&gt;&lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;version&gt;2.9.0&lt;/version&gt;&lt;/dependency&gt; 分别按照之前的方式放到parent模块和service-util的pom文件中。 然后在service-util中创建两个类RedisConfig和RedisUtil RedisConfig负责在spring容器启动时自动注入，而RedisUtil就是被注入的工具类以供其他模块调用。 RedisUtil1234567891011121314151617181920public class RedisUtil &#123; private JedisPool jedisPool; public void initPool(String host,int port ,int database)&#123; JedisPoolConfig poolConfig = new JedisPoolConfig(); poolConfig.setMaxTotal(200); poolConfig.setMaxIdle(30); poolConfig.setBlockWhenExhausted(true); poolConfig.setMaxWaitMillis(10*1000); poolConfig.setTestOnBorrow(true); jedisPool=new JedisPool(poolConfig,host,port,20*1000); &#125; public Jedis getJedis()&#123; Jedis jedis = jedisPool.getResource(); return jedis; &#125;&#125; RedisConfig1234567891011121314151617181920212223@Configurationpublic class RedisConfig &#123; //读取配置文件中的redis的ip地址 @Value("$&#123;spring.redis.host:disabled&#125;") private String host; @Value("$&#123;spring.redis.port:0&#125;") private int port; @Value("$&#123;spring.redis.database:0&#125;") private int database; @Bean public RedisUtil getRedisUtil()&#123; if(host.equals("disabled"))&#123; return null; &#125; RedisUtil redisUtil=new RedisUtil(); redisUtil.initPool(host,port,database); return redisUtil; &#125;&#125; 同时，任何模块想要调用redis都必须在application.properties配置，否则不会进行注入。 123spring.redis.host=redis.server.comspring.redis.port=6379spring.redis.database=0 现在可以在manage-service中的getSkuInfo()方法测试一下 123456try &#123; Jedis jedis = redisUtil.getJedis(); jedis.get("test","text_value" );&#125;catch (JedisConnectionException e)&#123; e.printStackTrace();&#125; 使用redis进行业务开发开始开发先说明redis key的命名规范，由于Redis不像数据库表那样有结构，其所有的数据全靠key进行索引，所以redis数据的可读性，全依靠key。 企业中最常用的方式就是： object:id:field 比如：sku:1314:info ​ user:1092:password 重构getSkuInfo方法 12345678910111213141516171819202122public SkuInfo getSkuInfo(String skuId)&#123; Jedis jedis = redisUtil.getJedis(); String skuKey= RedisConst.sku_prefix+skuId+RedisConst.skuInfo_suffix; String skuInfoJson = jedis.get(skuKey); if(skuInfoJson!=null )&#123; System.err.println( Thread.currentThread().getName()+"：命中缓存" ); SkuInfo skuInfo = JSON.parseObject(skuInfoJson, SkuInfo.class); jedis.close(); return skuInfo; &#125;else&#123; System.err.println( Thread.currentThread().getName()+"：未命中缓存" ); System.err.println( Thread.currentThread().getName()+"： 查询数据" ); SkuInfo skuInfoDB = getSkuInfoDB(skuId); String skuInfoJsonStr = JSON.toJSONString(skuInfoDB); jedis.setex(skuKey,RedisConst.skuinfo_exp_sec,skuInfoJsonStr); System.err.println( Thread.currentThread().getName()+"：数据库更新完毕" ); jedis.close(); return skuInfoDB; &#125;&#125; 以上基本实现使用缓存的方案。 高并发时可能会出现的问题在高并发环境下还有如下三个问题： 如果redis宕机了，或者链接不上，怎么办？ 如果redis缓存在高峰期到期失效，在这个时刻请求会向雪崩一样，直接访问数据库如何处理？ 如果用户不停地查询一条不存在的数据，缓存没有，数据库也没有，那么会出现什么情况，如何处理？ 缓存问题缓存穿透缓存穿透是指查询一个一定不存在的数据，由于缓存是不命中，将去查询数据库，但是数据库也无此记录，并且处于容错考虑，我们没有将这次查询的null写入缓存，这将导致这个不存在的数据每次请求都要到存储层去查询，失去了缓存的意义。在流量大时，可能DB就挂掉了，要是有人利用不存在的key频繁攻击我们的应用，这就是漏洞。 解决 空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。 缓存雪崩缓存雪崩是指在我们设置缓存时采用了相同的过期时间，导致缓存在某一时刻同时失效，请求全部转发到DB，DB瞬时压力过重雪崩。 解决 原有的失效时间基础上增加一个随机值，比如1-5分钟随机，这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件。 缓存击穿对于一些设置了过期时间的key，如果这些key可能会在某些时间点被超高并发地访问，是一种非常“热点”的数据。这个时候，需要考虑一个问题：如果这个key在大量请求同时进来前正好失效，那么所有对这个key的数据查询都落到db，我们称为缓存击穿。和缓存雪崩的区别： 缓存击穿是一个热点key失效 缓存雪崩是很多key集体失效 缓存在某个时间点过期的时候，恰好在这个时间点对这个Key有大量的并发请求过来，这些请求发现缓存过期一般都会从后端DB加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端DB压垮。 解决： 分布式锁 分布式锁 核心代码 12String token = UUID.randomUUID().toString();String lock = jedis.set(key, token, "NX", "EX",20); redissonhttps://github.com/redisson/redisson/wiki/1.-Overview 简介Redisson是一个在Redis的基础上实现的Java驻内存数据网格（In-Memory Data Grid）。它不仅提供了一系列的分布式的Java常用对象，还提供了许多分布式服务。其中包括(BitSet, Set, Multimap, SortedSet, Map, List, Queue, BlockingQueue, Deque, BlockingDeque, Semaphore, Lock, AtomicLong, CountDownLatch, Publish / Subscribe, Bloom filter, Remote service, Spring cache, Executor service, Live Object service, Scheduler service) Redisson提供了使用Redis的最简单和最便捷的方法。Redisson的宗旨是促进使用者对Redis的关注分离（Separation of Concern），从而让使用者能够将精力更集中地放在处理业务逻辑上。 整合引入 pom 123456&lt;!-- https://mvnrepository.com/artifact/org.redisson/redisson --&gt;&lt;dependency&gt; &lt;groupId&gt;org.redisson&lt;/groupId&gt; &lt;artifactId&gt;redisson&lt;/artifactId&gt; &lt;version&gt;3.10.5&lt;/version&gt;&lt;/dependency&gt; 配置 12spring.redis.host=192.168.159.130spring.redis.port=6379 配置类 1234567891011121314151617@Configurationpublic class GmallRedissonConfig &#123; @Value("$&#123;spring.redis.host&#125;") private String host; @Value("$&#123;spring.redis.port&#125;") private String port; @Bean public RedissonClient redissonClient()&#123; Config config = new Config(); config.useSingleServer().setAddress("redis://"+host+":"+port); RedissonClient redisson = Redisson.create(config); return redisson; &#125;&#125; redisson锁可重入锁（ReentrantLock） 基于Redis的Redisson分布式可重入锁RLock Java对象实现了java.util.concurrent.locks.Lock接口。同时还提供了异步（Async）、反射式（Reactive）和RxJava2标准的接口。 123RLock lock = redisson.getLock("anyLock");// 最常见的使用方法lock.lock(); 另外Redisson还通过加锁的方法提供了leaseTime的参数来指定加锁的时间。超过这个时间后锁便自动解开了 12345678910111213// 加锁以后10秒钟自动解锁// 无需调用unlock方法手动解锁lock.lock(10, TimeUnit.SECONDS);// 尝试加锁，最多等待100秒，上锁以后10秒自动解锁boolean res = lock.tryLock(100, 10, TimeUnit.SECONDS);if (res) &#123; try &#123; ... &#125; finally &#123; lock.unlock(); &#125;&#125; 12345678910111213public class Count &#123; Lock lock = new Lock(); public void print() &#123; lock.lock(); daAdd(); lock.unlock(); &#125; public void doAdd() &#123; lock.lock(); lock.unlock(); &#125;&#125; 当调用 print() 方法时，获得了锁，这时就无法再调用 doAdd() 方法，只有先释放锁才能调用，所以称这种锁为不可重入锁，也加自旋锁。 redisson分布式压力测试安装Linux yum -y install httpd-tools Windows 查看80端口有没有被占用，netstat -ano | findstr “80” 下载地址https://www.apachehaus.com/cgi-bin/download.plx 解压后，找到安装目录下的httpd.conf，修改为自己的安装目录 启动服务 http.exe 命令示例(并发200，一共1000个请求) ab -c 200 -n 1000 http:nginx负载均衡/压力方法 测试新建一个测试redisson控制层，加入测试代码 123456789101112131415161718192021@RequestMapping("lockTest")@ResponseBodypublic String lockTest()&#123; Jedis jedis = redisUtil.getJedis();// redis链接 RLock lock = redissonClient.getLock("redis-lock");//分布锁 //加锁 lock.lock(); try &#123; String v = jedis.get("k");//获取value System.err.print("==&gt;"+v);//打印value if(StringUtil.isBlank(v))&#123; v = "1"; &#125; int inum = Integer.parseInt(v);//获得value的值 jedis.set("k", inum+1+"");//value增加1 jedis.close(); &#125; finally &#123; lock.unlock(); &#125; return "success";&#125; 启动n个测试redisson控制层的微服务 配置nginx的负载均衡到测试redisson控制层的微服务 123456789upstream redisTest &#123; server 127.0.0.1:8071 weight=3; server 127.0.0.1:8072 weight=3; server 127.0.0.1:8073 weight=3;&#125; 配置nginx的默认代理地址 123456789 location / &#123; #root D:/software/upload; proxy_pass http://redisTest; index index.html index.htm; &#125; 用 apache 的 ab 压力测试命令访问 nginx 来压测分布式的 redisson 控制层的微服务 同时观察 redis 的被并发的 k 的增长情况]]></content>
      <categories>
        <category>个人项目</category>
        <category>电商</category>
      </categories>
      <tags>
        <tag>个人项目</tag>
        <tag>电商</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FastDFS文件服务器]]></title>
    <url>%2F2019%2F10%2F21%2FFastDFS%E6%96%87%E4%BB%B6%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
    <content type="text"><![CDATA[FastDFS介绍FastDFS是一个由 C 语言实现的开源轻量级分布式文件系统，作者余庆(happyfish100)，支持 Linux、FreeBSD、AID 等 Unix 系统，解决了大数据存储和读写负载均衡等问题，适合存储 4KB~500MB 之间的小文件，如图片网站、短视频网站、文档、app 下载站等，UC、京东、支付宝、迅雷、酷狗等都有使用。 FastDFS上传的流程 FastDFS架构包括 Tracker server和Storage server。客户端请求Tracker server进行文件上传、下载，通过Tracker server调度最终由Storage server完成文件上传和下载。 Tracker Server作用是负载均衡和调度，通过Tracker server在文件上传时可以根据一些策略找到Storage server提供文件上传服务。可以将tracker称为追踪服务器或调度服务器。 Storage Server作用是文件存储，客户端上传的文件最终存储在Storage服务器上，Storage server没有实现自己的文件系统而是利用操作系统的文件系统来管理文件。可以将storage称为存储服务器。 FastDFS下载的流程 FastDFS的安装安装顺序 libfastcommon fdfs_tracker 依赖：Gcc、libevent、perl fdfs_storage FastDFS-nginx-module nginx 依赖：pcre-develzlib-devel 功能文件目录opt/fastdfs 数据存储目录 usr/local/fdfs 启动文件目录 etc/fdfs 配置文件目录 usr/bin/fdfs_trackerd 启动配置 etc/init.d/fdfs_trackerd 启动服务脚本 FastDFS–tracker安装FastDFS安装环境 FastDFS是C语言开发，建议在linux上运行，本教程使用Centos7.4作为安装环境。 安装gcc 依赖环境 yum install gcc-c++ -y libevent yum -y install libevent 如果没有perl库，需要使用yum install perl* 命令安装一下 yum -y install zlib zlib-devel pcre pcre-devel gcc gcc-c++ openssl openssl-devel libevent libevent-devel perl unzip net-tools wget 安装libfastcommon 上传压缩包文件libfastcommonV1.0.7.tar.gz 到 /usr/local目录下，并解压。 tar -zxvf libfastcommonV1.0.7.tar.gz 进入到解压后的文件夹中 进行编译 ./make.sh 如果出现编译perl 不识别 运行下面这段命令 # yum -y install zlib zlib-devel pcre pcre-devel gcc gcc-c++ openssl openssl-devel libevent libevent-devel perl unzip net-tools wget 安装 ./make.sh install 注意：libfastcommon安装好后会自动将库文件拷贝至/usr/lib64下，由于FastDFS程序引用usr/lib目录所以需要将/usr/lib64下的库文件拷贝至/usr/lib下。 安装tracker 上传资料FastDFS_v5.05.tar.gz到 /usr/local 目录下 解压编译安装 tar -zxvf FastDFS_v5.05.tar.gz cd FastDFS ./make.sh ./make.sh install 安装成功之后，将安装目录下的conf下的文件拷贝到/etc/fdfs/下。 cd conf cp * /etc/fdfs/ 修改配置文件 vim /etc/fdfs/tracker.conf 在/opt/下创建fastdfs文件夹 mkdir /opt/fastdfs 设置启动项 启动服务 mkdir /usr/local/fdfs 拷贝安装目录下stop.sh 和restart.sh 到/usr/local/fdfs/ cp restart.sh /usr/local/fdfs/ cp stop.sh /usr/local/fdfs/ 修改启动脚本 vim /etc/init.d/fdfs_trackerd 把启动脚本中的路径按照上图修改 修改完毕后 注册服务 chkconfig –add fdfs_trackerd 然后可以用service fdfs_trackerd start 启动测试 如下图 FastDFS—storage配置修改配置文件 vim /etc/fdfs/storage.conf 创建fdfs_storage文件夹 mkdir /opt/fastdfs/fdfs_storage 设置服务 vim /etc/init.d/fdfs_storaged chkconfig - -add fdfs_storaged 启动服务 service fdfs_storaged start 上传图片测试 FastDFS安装成功可通过/usr/bin/fdfs_test测试上传、下载等操作。 修改/etc/fdfs/client.conf [root@localhost ~]# vim /etc/fdfs/client.conf base_path=/opt/fastdfs tracker_server=192.168.67.163:22122 比如将/root下的日志上传到FastDFS中： /usr/bin/fdfs_test /etc/fdfs/client.conf upload /root/winteriscoming.jpg 对应的上传路径： /opt/fastdfs/fdfs_storage/data /00/00/wKhDo1qipbiAJC6iAAB1tayPlqs094_big.jpg FastDFS整合nginx 安装nginx整合插件fastdfs-nginx-module 上传fastdfs-nginx-module_v1.16.tar.gz上传到 /usr/local，并解压 tar -zxvf fastdfs-nginx-module_v1.16.tar.gz 编辑配置文件：修改config文件将/usr/local/路径改为/usr/ (这里要修改三个路径) vim fastdfs-nginx-module/src/config 将FastDFS-nginx-module/src下的mod_fastdfs.conf拷贝至/etc/fdfs/下 [root@localhost src]# cp mod_fastdfs.conf /etc/fdfs/ 并修改mod_fastdfs.conf的内容： vim /etc/fdfs/mod_fastdfs.conf 继续修改 继续修改 url中包含group名称 继续修改 #指定文件存储路径 将libfdfsclient.so拷贝至/usr/lib下 [root@localhost src]# cp /usr/lib64/libfdfsclient.so /usr/lib/ 安装nginx创建nginx/client目录 [root@localhost src]# mkdir -p /var/temp/nginx/client 安装环境 安装pcre库 yum -y install pcre-devel 安装zlib库 yum install -y zlib-devel 上传nginx 上传nginx压缩包到/usr/local目录下，解压 tar -zxvf nginx-1.12.2.tar.gz 添加fastdfs-nginx-module模块 cd nginx-1.8.0 12345678910111213./configure \--prefix=/usr/local/nginx \--pid-path=/var/run/nginx/nginx.pid \--lock-path=/var/lock/nginx.lock \--error-log-path=/var/log/nginx/error.log \--http-log-path=/var/log/nginx/access.log \--with-http_gzip_static_module \--http-client-body-temp-path=/var/temp/nginx/client \--http-proxy-temp-path=/var/temp/nginx/proxy \--http-fastcgi-temp-path=/var/temp/nginx/fastcgi \--http-uwsgi-temp-path=/var/temp/nginx/uwsgi \--http-scgi-temp-path=/var/temp/nginx/scgi \--add-module=/usr/local/fastdfs-nginx-module/src 配置成功 编译 [root@localhost nginx-1.12.2]# make 安装 [root@localhost nginx-1.12.2]# make install 编辑nginx.conf vim /usr/local/nginx/conf/nginx.conf 启动nginx /usr/local/nginx/sbin/nginx 设置开机启动 [root@iZ2zednyjjxxq7k3i2dwsfZ nginx-1.12.2]# vim /etc/rc.d/rc.local 需要关闭防火墙 service iptables stop 永久关闭 chkconfig iptables off 测试 /usr/bin/fdfs_test /etc/fdfs/client.conf upload /root/ty.jpg 使用Java客户端调用FastDFS加载Maven依赖 fastdfs 没有在中心仓库中提供获取的依赖坐标。 只能自己通过源码方式编译，打好jar 包，安装到本地仓库。 官方仓库地址： https://github.com/happyfish100/fastdfs-client-java 直接用idea 直接把这个源码作为模块导入工程 别的不用改，只把pom.xml中的版本改成1.27。 然后右边 执行install 就好了 安装好了 ，别的模块就可以直接使用这个坐标了。 12&lt;**groupId**&gt;org.csource&lt;/**groupId**&gt; &lt;**artifactId**&gt;fastdfs-client-java&lt;/**artifactId**&gt; &lt;**version**&gt;1.27&lt;/**version**&gt; 而这个fastdfs-client-java模块可以从idea 中删除。 12345678910111213141516@RunWith(SpringRunner.class)@SpringBootTest@Testpublic void textFileUpload() throws IOException, MyException &#123; String file = this.getClass().getResource("/tracker.conf").getFile(); ClientGlobal.init(file); TrackerClient trackerClient=new TrackerClient(); TrackerServer trackerServer=trackerClient.getConnection(); StorageClient storageClient=new StorageClient(trackerServer,null); String orginalFilename="e://victor.jpg"; String[] upload_file = storageClient.upload_file(orginalFilename, "jpg", null); for (int i = 0; i &lt; upload_file.length; i++) &#123; String s = upload_file[i]; System.out.println("s = " + s); &#125;&#125; 配置tracker.conf文件 1234567tracker_server=192.168.67.162:22122# 连接超时时间，针对socket套接字函数connect，默认为30秒connect_timeout=30000# 网络通讯超时时间，默认是60秒network_timeout=60000 打印结果 这个打印结果实际上就是我们访问的路径，加上服务器地址我们可以拼接成一个字符串 http://192.168.67.163/group1/M00/00/00/wKhDo1qjU2qAWKQmAAATla901AQ534.jpg 直接放到浏览器去访问 对接到业务模块中 在修改FileUploadController的方法 123456789101112131415161718192021222324@Value("$&#123;fileServer.url&#125;")String fileUrl;@RequestMapping(value = "fileUpload",method = RequestMethod.POST)public String fileUpload(@RequestParam("file") MultipartFile file) throws IOException, MyException &#123; String imgUrl=fileUrl; if(file!=null)&#123; System.out.println("multipartFile = " + file.getName()+"|"+file.getSize()); String configFile = this.getClass().getResource("/tracker.conf").getFile(); ClientGlobal.init(configFile); TrackerClient trackerClient=new TrackerClient(); TrackerServer trackerServer=trackerClient.getConnection(); StorageClient storageClient=new StorageClient(trackerServer,null); String filename= file.getOriginalFilename(); String extName = StringUtils.substringAfterLast(filename, "."); String[] upload_file = storageClient.upload_file(file.getBytes(), extName, null); imgUrl=fileUrl ; for (int i = 0; i &lt; upload_file.length; i++) &#123; String path = upload_file[i]; imgUrl+="/"+path; &#125; &#125; 利用@Value(“${fileServer.url}”)标签可以引用application.properties中的值]]></content>
      <categories>
        <category>FastDFS</category>
        <category>文件服务器</category>
      </categories>
      <tags>
        <tag>FastDFS</tag>
        <tag>文件服务器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[仿京东商城项目之pms后台管理（三）]]></title>
    <url>%2F2019%2F10%2F21%2F%E4%BB%BF%E4%BA%AC%E4%B8%9C%E5%95%86%E5%9F%8E%E9%A1%B9%E7%9B%AE%E4%B9%8Bpms%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
    <content type="text"><![CDATA[pms整体业务 三级分类的查询 商品的平台属性列表的增删改查 商品spu的添加 spu列表查询 spu的销售属性、属性值、图片上传 商品sku的添加 sku信息、关联的销售属性、关联的平台属性、图片 pms数据库表的设计基本信息—分类一般情况可以分为两级或者三级。该项目一共分为三级，即一级分类、二级分类、三级分类。 比如：家用电器是一级分类，电视是二级分类，那么超薄电视就是三级分类。 数据库结构 基本信息—平台属性平台属性和平台属性值 平台属性和平台属性值主要用于商品的检索，每个三级分类对应的属性都不同。 而每个商品对应的每种属性都有对应的属性值。 比如电脑整机的一级分类下，有笔记本、游戏本、台式机、一体机的二级分类。 笔记本这个二级分类又包含了处理器、屏幕尺寸、内存容量、硬盘容量、显卡类别这些属性。 那么针对联想某个型号的笔记本，它作为笔记本这种分类，每个分类属性都有对应的值，cpu(属性)是i7(属性值)的，内存(属性)是8G(属性值)的，屏幕尺寸(属性)是14寸(属性值)的。 基本信息—销售属性销售属性，就是商品详情页右边，可以通过销售属性来定位一组spu下的哪款sku。可以让当前的商品详情页，跳转到自己的“兄弟”商品。 销售属性与平台属性 ​ 一般每种商品的销售属性不会太多，大约1-4种。整个电商的销售属性种类也不会太多，大概10种以内。比如：颜色、尺寸、版本、套装等等。不同销售属性的组合也就构成了一个spu下多个sku的结构。 基本信息—spu与 skuSPU(Standard Product Unit)：标准化产品单元。是商品信息聚合的最小单位，是一组可复用、易检索的标准化信息的集合，该集合描述了一个产品的特性。 SKU=Stock Keeping Unit（库存量单位）。即库存进出计量的基本单元，可以是以件，盒，托盘等为单位。SKU这是对于大型连锁超市DC（配送中心）物流管理的一个必要的方法。现在已经被引申为产品统一编号的简称，每种产品均对应有唯一的SKU号。 比如，咱们购买一台iPhoneX手机，iPhoneX手机就是一个SPU，但是你购买的时候，不可能是以iPhoneX手机为单位买的，商家也不可能以iPhoneX为单位记录库存。必须要以什么颜色什么版本的iPhoneX为单位。比如，你购买的是一台银色、128G内存的、支持联通网络的iPhoneX ，商家也会以这个单位来记录库存数。那这个更细致的单位就叫库存单元（SKU）。 首先通过检索搜索出来的商品列表中，每个商品都是一个sku。每个sku都有自己独立的库存数。也就是说每一个商品详情展示都是一个sku。 那spu又是干什么的呢？ 一般的电商系统你点击进去以后，都能看到这个商品关联了其他好几个类似的商品，而且这些商品很多的信息都是共用的，比如商品图片，海报、销售属性等。 ​ 那么系统是靠什么把这些sku识别为一组的呢，那是这些sku都有一个公用的spu信息。而它们公共的信息，都放在spu信息下。 pms数据模型根据以上的需求，以此将关联的数据库表结构设计为如下： 后台管理模块开发搭建后台的manage-web模块 application.properties 12345678910111213server.port=8083spring.thymeleaf.cache=falsespring.thymeleaf.mode=LEGACYHTML5spring.dubbo.application.name=manage-webspring.dubbo.registry.protocol=zookeeperspring.dubbo.registry.address=192.168.67.159:2181spring.dubbo.base-package=com.dcxiaolou.tinyjdspring.dubbo.protocol.name=dubbospring.dubbo.consumer.timeout=10000spring.dubbo.consumer.check=false 搭建后台的manage-service模块 application.properties 12345678910111213server.port=8073logging.level.root=debugspring.dubbo.application.name=manage-servicespring.dubbo.registry.protocol=zookeeperspring.dubbo.registry.address=192.168.67.159:2181spring.dubbo.base-package=com.dcxiaolou.tinyjdspring.dubbo.protocol.name=dubbospring.datasource.url=jdbc:mysql://192.168.159.3:3306/tinyjd?characterEncoding=UTF-8spring.datasource.username=rootspring.datasource.password=123456spring.datasource.driver-class-name=com.mysql.jdbc.Driver]]></content>
      <categories>
        <category>个人项目</category>
        <category>电商</category>
      </categories>
      <tags>
        <tag>个人项目</tag>
        <tag>电商</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dubbo简介]]></title>
    <url>%2F2019%2F10%2F20%2FDubbo%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[Dubbo 简介 Dubbo: 一个分布式、高性能、透明化的RPC服务框架 RPC(Remote Procedure Call Protocol)指远程过程调用协议 RPC解析: 客户端通过互联网调用远程服务器，不知道远程服务器具体实现，只知道远程服务器提供了什么功能 RPC最大优点: 数据安全性 作用: 提供服务自动注册、自动发现等高效服务治理方案 Dubbo的基本概念 ​ 服务提供者（Provider）：暴露服务的服务提供方，服务提供者在启动时，向注册中心注册自己提供的服务。 ​ 服务消费者（Consumer）: 调用远程服务的服务消费方，服务消费者在启动时，向注册中心订阅自己所需的服务，服务消费者从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。 ​ Container：Dubbo容器，依赖于 Spring 容器 ​ 注册中心（Registry）：注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者 ​ 监控中心（Monitor）：服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心 ​ 虚线都是异步访问，实线都是同步访问 ​ 蓝色虚线:在启动时完成的功能 ​ 绿色虚线(实线)都是程序运行过程中执行的功能 ​ 所有的角色都是可以在单独的服务器上.所以必须遵守特定的协议. 调用关系说明 服务容器负责启动，加载，运行服务提供者。 服务提供者在启动时，向注册中心注册自己提供的服务。 服务消费者在启动时，向注册中心订阅自己所需的服务。 注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。 服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。 服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。 Dubbo 支持的注册中心 Zookeeper 优点:支持网络集群 缺点:稳定性受限于Zookeeper Redis 优点:性能高. 缺点:对服务器环境要求较高. Multicast 优点:免中心化,不需要额外安装软件. 缺点:建议同机房(局域网)内使用 Simple 适用于测试环境.不支持集群. Dubbo 支持的协议 Dubbo Dubbo官方推荐的协议. 本质:使用NIO和线程池进行处理. 缺点:大文件传输时可能出现文件传输失败问题. RMI JDK提供的协议,远程方法调用协议. 缺点:偶尔连接失败. 优点:JDK原生,不需要进行额外配置(导入jar) Hession 优点:基于http协议,http请求支持. 缺点:需要额外导入jar,并在短连接时性能低 如何在项目中引入 dubbodubbo其实是一组jar包，通过maven引入就可以。 1234567891011121314151617181920212223242526272829&lt;properties&gt; &lt;dubbo-starter.version&gt;1.0.10&lt;/dubbo-starter.version&gt; &lt;dubbo.version&gt;2.6.0&lt;/dubbo.version&gt; &lt;zkclient.version&gt;0.10&lt;/zkclient.version&gt; &lt;/properties&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;dubbo&lt;/artifactId&gt; &lt;version&gt;$&#123;dubbo.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.101tec&lt;/groupId&gt; &lt;artifactId&gt;zkclient&lt;/artifactId&gt; &lt;version&gt;$&#123;zkclient.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.gitee.reger&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-dubbo&lt;/artifactId&gt; &lt;version&gt;$&#123;dubbo-starter.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; 注册中心为 Zookeeper Provider（服务提供方）相关配置 123456789spring: dubbo: application: name: cart-service protocol: dubbo registry: protocol: zookeeper address: 192.168.159.3:2181 base-package: com.dcxiaolou.tinyJD Consumer（服务消费方）相关配置 123456789101112spring: dubbo: application: name: cart-web protocol: dubbo registry: protocol: zookeeper address: 192.168.159.3:2181 consumer: timeout: 600000 check: false base-package: com.dcxiaolou.tinyJD 配置说明： application.name 是服务名，不能跟别的dubbo提供端重复 registry.protocol 是指定注册中心协议 registry.address 是注册中心的地址加端口号 protocol.name 是分布式固定是dubbo,不要改 base-package 注解方式要扫描的包 port 是服务提供端为zookeeper暴露的端口，不能跟别的dubbo提供端重复 consumer.timeout 是访问提供端服务的超时时间，默认是1000毫秒 consumer.check 是启动消费端时，是否检查服务端能否正常访问。如果选择true，那启动消费端时，必须保证提供端服务正常，否则接口无法注入。 dubbo的使用分为提供端和消费端。消费端的注解为@Reference，提供端的注解为@Service（注意不要引入spring的包，而是alibaba.dubbo对应的包） Dubbo Admin 管理界面本质就是一个web项目，获取注册中心内Provider注册的信息用页面呈现出来 实现步骤 把dubbo-admin-2.5.3.war上传到服务器tomcat中. 启动tomcat完成后关闭tomcat，删除上传的dubbo-admin-2.5.3.war 为什么要删除:需要修改解压后的文件夹，如果不删除.war文件，下次重启tomcat会还原成未修改状态 进入dubbo-admin-2.5.3/WEB-INF/dubbo.properties,修改第一行为zookeeper的ip和端口 第二行和第三行为管理界面的用户名和密码 启动tomcat, 在浏览器地址栏访问tomcat中dubbo项目 dubbo 与 springcloud 的区别Dubbo出于阿里系，是阿里巴巴服务化治理的核心框架，并被广泛应用于中国各互联网公司；只需要通过spring配置的方式即可完成服务化，对于应用无入侵。框架本身的成熟度以及文档的完善程度，完全能满足各大互联网公司的业务需求。但如果我们需要使用配置中心、分布式跟踪这些内容都需要自己去集成，这样无形中增加了使用Dubbo 的难度。 Spring Cloud 是大名鼎鼎的 Spring 家族的产品， 专注于企业级开源框架的研发。Spring Cloud 自从发展到现在，仍然在不断的高速发展，几乎考虑了服务治理的方方面面，开发起来非常的便利和简单。Spring Cloud更新的非常快，企业需要根据自身的研发水平和所处阶段选择合适的架构来解决业务问题，不管是Dubbo还是Spring Cloud都是实现微服务有效的工具。]]></content>
      <categories>
        <category>Dubbo</category>
      </categories>
      <tags>
        <tag>Dubbo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[仿京东管理项目之架构（二）]]></title>
    <url>%2F2019%2F10%2F20%2F%E4%BB%BF%E4%BA%AC%E4%B8%9C%E7%AE%A1%E7%90%86%E9%A1%B9%E7%9B%AE%E4%B9%8B%E6%9E%B6%E6%9E%84%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[一、分布式架构将各个应用通过分层独立出来，可以利用rpc实现web与service、service与service的互相调用，提高了代码的复用性。 缺点： 每个调用的模块要存储一份完整的被调用模块的位置和状态，一旦位置和状态发生变化，就要更新所有涉及的配置。 面向服务的分布式架构 随着架构不断增大，服务节点也越来越多，服务之间的调用和依赖关系也越来越复杂，需要有一个统一的中心来调度、路由、管理所有的服务，基于这个中心构建的这个星型架构就是现在目前最主流的SOA分布式架构。 二、分布式工程的模块搭建1 创建bean模块(与interface一起整合为api模块) bean模块的pom.xml 1234567891011121314151617181920212223242526&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.dcxiaolou.tinyJD&lt;/groupId&gt; &lt;artifactId&gt;tinyjd-api&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;dependencies&gt; &lt;!--通用mapper--&gt; &lt;dependency&gt; &lt;groupId&gt;tk.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mapper-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.2.3&lt;/version&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 由于依赖包分布于多个模块中，最好有一个地方能够把所有依赖的版本通用管理起来。 这就用到了maven的&lt;parent&gt;概念。可以让所有的模块都继承这个parent模块，由这个parent模块来管理版本。 2 搭建parent模块 parent模块的 pom.xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.21.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.dcxiaolou.tinyJD&lt;/groupId&gt; &lt;artifactId&gt;tinyjd-parent&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;fastjson.verion&gt;1.2.46&lt;/fastjson.verion&gt; &lt;dubbo-starter.version&gt;1.0.10&lt;/dubbo-starter.version&gt; &lt;dubbo.version&gt;2.6.0&lt;/dubbo.version&gt; &lt;zkclient.version&gt;0.10&lt;/zkclient.version&gt; &lt;mybatis.version&gt;1.3.1&lt;/mybatis.version&gt; &lt;nekohtml.verion&gt;1.9.20&lt;/nekohtml.verion&gt; &lt;xml-apis.version&gt;1.4.01&lt;/xml-apis.version&gt; &lt;batik-ext.version&gt;1.11&lt;/batik-ext.version&gt; &lt;jsoup.version&gt;1.11.2&lt;/jsoup.version&gt; &lt;httpclient.version&gt;4.5.5&lt;/httpclient.version&gt; &lt;commons-lang3.version&gt;3.7&lt;/commons-lang3.version&gt; &lt;mapper-starter.version&gt;1.2.3&lt;/mapper-starter.version&gt; &lt;jedis.version&gt;2.9.0&lt;/jedis.version&gt; &lt;jest.version&gt;5.3.3&lt;/jest.version&gt; &lt;jna.version&gt;4.5.1&lt;/jna.version&gt; &lt;beanUtils.version&gt;1.9.3&lt;/beanUtils.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;$&#123;fastjson.verion&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;dubbo&lt;/artifactId&gt; &lt;version&gt;$&#123;dubbo.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;!--zookeeper客户端工具--&gt; &lt;groupId&gt;com.101tec&lt;/groupId&gt; &lt;artifactId&gt;zkclient&lt;/artifactId&gt; &lt;version&gt;$&#123;zkclient.version&#125;&lt;/version&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;!--SpringBoot整合Dubbo的中间包--&gt; &lt;groupId&gt;com.gitee.reger&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-dubbo&lt;/artifactId&gt; &lt;version&gt;$&#123;dubbo-starter.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;!--SpringBoot整合MyBatis的中间包--&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;$&#123;mybatis.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!--Thymeleaf依赖包--&gt; &lt;dependency&gt; &lt;groupId&gt;net.sourceforge.nekohtml&lt;/groupId&gt; &lt;artifactId&gt;nekohtml&lt;/artifactId&gt; &lt;version&gt;$&#123;nekohtml.verion&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;xml-apis&lt;/groupId&gt; &lt;artifactId&gt;xml-apis&lt;/artifactId&gt; &lt;version&gt;$&#123;xml-apis.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.xmlgraphics&lt;/groupId&gt; &lt;artifactId&gt;batik-ext&lt;/artifactId&gt; &lt;version&gt;$&#123;batik-ext.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.jsoup&lt;/groupId&gt; &lt;artifactId&gt;jsoup&lt;/artifactId&gt; &lt;version&gt;$&#123;jsoup.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!--java发送http请求--&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt; &lt;artifactId&gt;httpclient&lt;/artifactId&gt; &lt;version&gt;$&#123;httpclient.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;!--java基本类型处理：if (StringUtils.isBlank(str)) --&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt; &lt;version&gt;$&#123;commons-lang3.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;!--通用mapper--&gt; &lt;groupId&gt;tk.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mapper-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;$&#123;mapper-starter.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;!--redis客户端--&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;version&gt;$&#123;jedis.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;!--elasticSearch--&gt; &lt;groupId&gt;io.searchbox&lt;/groupId&gt; &lt;artifactId&gt;jest&lt;/artifactId&gt; &lt;version&gt;$&#123;jest.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;!--elasticSearch依赖包字节码--&gt; &lt;groupId&gt;net.java.dev.jna&lt;/groupId&gt; &lt;artifactId&gt;jna&lt;/artifactId&gt; &lt;version&gt;$&#123;jna.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;!--用于操作JAVA BEAN的工具包--&gt; &lt;groupId&gt;commons-beanutils&lt;/groupId&gt; &lt;artifactId&gt;commons-beanutils&lt;/artifactId&gt; &lt;version&gt;$&#123;beanUtils.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 3 搭建util模块用于放置除了通用mapper以外其他的第三方依赖 可以把所有的第三方依赖包分为三种 web业务模块用到的第三方包,比如文件上传客户端、页面渲染工具、操作cookie的工具类等 service业务模块用到的第三方包，比如jdbc、mybatis、jedis、activemq工具包等 通用型的第三方包，比如fastjson、httpclient、apache工具包等 只有本模块用到的第三方包，比如es等 创建tinyjd-common-util模块、tinyjd-web-util模块、tinyjd–service-util模块 首先先分析具体哪些包是通用的 tinyjd-common-util 第三方包 说明 spring-boot-starter-test 测试(springboot有默认版本号) spring-boot-starter-web 内含tomcat容器、HttpSevrletRequest等 (springboot有默认版本号) fastjson json工具 commons-lang3 apache工具库 commons-beanutils apache处理实体bean工具库 commons-codec apache解码工具库 httpclient restful调用客户端 tinyjd-web-util 第三方包 说明 Thymeleaf springboot自带页面渲染工具(springboot有默认版本号) tinyjd–service-util 第三方包 说明 spring-boot-starter-jdbc 数据库驱动(springboot有默认版本号) mysql-connector-java 数据库连接器(springboot有默认版本号) mybatis-spring-boot-starter mybatis tinyjd-common-util的pom.xml 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;com.dcxiaolou.tinyJD&lt;/groupId&gt; &lt;artifactId&gt;tinyjd-parent&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;groupId&gt;com.dcxiaolou.tinyJD&lt;/groupId&gt; &lt;artifactId&gt;tinyjd-common-util&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt; &lt;artifactId&gt;httpclient&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt; &lt;version&gt;3.7&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-beanutils&lt;/groupId&gt; &lt;artifactId&gt;commons-beanutils&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-codec&lt;/groupId&gt; &lt;artifactId&gt;commons-codec&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.46&lt;/version&gt; &lt;/dependency&gt; &lt;!--dubbo依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;dubbo&lt;/artifactId&gt; &lt;version&gt;2.6.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.101tec&lt;/groupId&gt; &lt;artifactId&gt;zkclient&lt;/artifactId&gt; &lt;version&gt;0.10&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.gitee.reger&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-dubbo&lt;/artifactId&gt; &lt;version&gt;1.0.10&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; tinyjd-web-util的pom.xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;com.dcxiaolou.tinyJD&lt;/groupId&gt; &lt;artifactId&gt;tinyjd-parent&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;groupId&gt;com.dcxiaolou.tinyJD&lt;/groupId&gt; &lt;artifactId&gt;tinyjd-web-util&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;properties&gt; &lt;thymeleaf.version&gt;3.0.9.RELEASE&lt;/thymeleaf.version&gt; &lt;!-- 布局功能的支持程序 thymeleaf3主程序 layout2以上版本 --&gt; &lt;!-- thymeleaf2 layout1--&gt; &lt;thymeleaf-layout-dialect.version&gt;2.2.2&lt;/thymeleaf-layout-dialect.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.dcxiaolou.tinyJD&lt;/groupId&gt; &lt;artifactId&gt;tinyjd-common-util&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.webjars&lt;/groupId&gt; &lt;artifactId&gt;bootstrap&lt;/artifactId&gt; &lt;version&gt;4.0.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.webjars&lt;/groupId&gt; &lt;artifactId&gt;jquery&lt;/artifactId&gt; &lt;version&gt;3.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt; &lt;artifactId&gt;jjwt&lt;/artifactId&gt; &lt;version&gt;0.9.0&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; tinyjd-service-util的pom.xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;com.dcxiaolou.tinyJD&lt;/groupId&gt; &lt;artifactId&gt;tinyjd-parent&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;groupId&gt;com.dcxiaolou.tinyJD&lt;/groupId&gt; &lt;artifactId&gt;tinyjd-service-util&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.dcxiaolou.tinyJD&lt;/groupId&gt; &lt;artifactId&gt;tinyjd-common-util&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.3.4&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--activemq--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-activemq&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.activemq&lt;/groupId&gt; &lt;artifactId&gt;activemq-pool&lt;/artifactId&gt; &lt;version&gt;5.15.2&lt;/version&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt;]]></content>
      <categories>
        <category>个人项目</category>
        <category>电商</category>
      </categories>
      <tags>
        <tag>个人项目</tag>
        <tag>电商</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[仿京东商城项目之简介（一）]]></title>
    <url>%2F2019%2F10%2F18%2F%E4%BB%BF%E4%BA%AC%E4%B8%9C%E5%95%86%E5%9F%8E%E9%A1%B9%E7%9B%AE%E4%B9%8B%E7%AE%80%E4%BB%8B%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[代码存放地址：https://github.com/dcxiaolou/tinyJD 本次介绍的项目是一个综合性的B2C平台，非常类似京东商城 为什么要写仿京东商城项目？因为就互联网平台来说，电商网站有很多典型的特征： 访问量大 数据量大 并发高，实战性强 有一定的业务复杂性,技术点丰富 涉及支付考虑一定安全性 项目架构 功能流程 使用到的技术 功能展示友情提醒：以下 gif 图片较大，如果加载失败，请刷新页面或右键图片 —&gt; 在新标签页中打开图片 后台管理 前台功能 微博登录 添加商品及搜索 更多详细内容请访问 https://dcxiaolou.github.io/ 或 https://0teem0.coding-pages.com/]]></content>
      <categories>
        <category>个人项目</category>
        <category>电商</category>
      </categories>
      <tags>
        <tag>个人项目</tag>
        <tag>电商</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Flume将Kafka中的数据导入到HDFS时native-lzo library not available问题]]></title>
    <url>%2F2019%2F10%2F14%2F%E4%BD%BF%E7%94%A8Flume%E5%B0%86Kafka%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E5%AF%BC%E5%85%A5%E5%88%B0HDFS%E6%97%B6native-lzo%20library%20not%20available%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[环境：jdk 1.8、Hadoop 2.7.2、Flume 1.7.0、Kafka 0.11.0.2 在 Hadoop 中使用了 LZO 来进行压缩 数据导入到 Kafka 后，使用 Flume 来消费Kafka中的数据，将数据导入到 HDFS 中 在导入的过程中出现错误 java.lang.RuntimeException: native-lzo library not available 错误，同时在 Hadoop 的 web 界面中可以看见很多以 .lzo.tmp 结尾的文件 解决：在使用 Flume 导入数据的节点上重新安装 LZO 和 LZOP 准备工作： yum -y install lzo-devel zlib-devel gcc autoconf automake libtool 安装 LZO wget http://www.oberhumer.com/opensource/lzo/download/lzo-2.06.tar.gztar -zxvf lzo-2.06.tar.gz./configure -enable-shared -prefix=/opt/module/lzo/make &amp;&amp; make install 安装 LZOPwget http://www.lzop.org/download/lzop-1.03.tar.gztar -zxvf lzop-1.03.tar.gz./configure -enable-shared -prefix=/opt/module/lzop/make &amp;&amp; make install 把 LZOP 复制到/usr/bin/ ln -s /opt/module/lzop/bin/lzop /usr/bin/lzop 测试 LZOP lzop /tmp/logs/app-2019-01-01.log 会生成一个以 .lzo 为后缀的压缩文件：/tmp/logs/app-2019-01-01.log.lzo 安装Hadoop-lzo 先下载lzo的jar项目 https://github.com/twitter/hadoop-lzo/archive/master.zip 下载后的文件名是hadoop-lzo-master，它是一个zip格式的压缩包，先进行解压，然后用maven编译。生成hadoop-lzo-0.4.20.jar。 配置 Hadoop 在文件$HADOOP_HOME/etc/hadoop/hadoop-env.sh中追加如下内容： 1export LD_LIBRARY_PATH=/usr/local/hadoop/lzo/lib 在文件$HADOOP_HOME/etc/hadoop/core-site.xml中追加如下内容： 12345678910111213&lt;property&gt; &lt;name&gt;io.compression.codecs&lt;/name&gt; &lt;value&gt;org.apache.hadoop.io.compress.GzipCodec, org.apache.hadoop.io.compress.DefaultCodec, com.hadoop.compression.lzo.LzoCodec, com.hadoop.compression.lzo.LzopCodec, org.apache.hadoop.io.compress.BZip2Codec &lt;/value&gt;&lt;/property&gt;&lt;property&gt; &lt;name&gt;io.compression.codec.lzo.class&lt;/name&gt; &lt;value&gt;com.hadoop.compression.lzo.LzoCodec&lt;/value&gt;&lt;/property&gt; 在文件$HADOOP_HOME/etc/hadoop/mapred-site.xml中追加如下内容： 123456789101112&lt;property&gt; &lt;name&gt;mapred.compress.map.output&lt;/name&gt; &lt;value&gt;true&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;mapred.map.output.compression.codec&lt;/name&gt; &lt;value&gt;com.hadoop.compression.lzo.LzoCodec&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;mapred.child.env&lt;/name&gt; &lt;value&gt;LD_LIBRARY_PATH=/usr/local/hadoop/lzo/lib&lt;/value&gt; &lt;/property&gt; 最后重启 Hadoop 和 Flume 即可解决问题 参考： https://blog.csdn.net/zhangzhaokun/article/details/17595325]]></content>
      <categories>
        <category>Flume</category>
        <category>LZO</category>
      </categories>
      <tags>
        <tag>Flume</tag>
        <tag>LZO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Typora及Markdown语法]]></title>
    <url>%2F2019%2F09%2F19%2FTyproa%E5%8F%8AMarkdown%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Typora是一款轻便简介的Markdown编辑器，支持即时渲染技术，所见即所得。 Typora能够插入本地图片和来自网络的图片，但是，如果编写完后的.md文件要进行网络传输则插入的本地图片将会显示不出来。要解决该问题可以使用图床，如PicGo。PicGo在上传图片之后会自动将图片的链接复制到粘贴板中，并支持微博图床、七牛图床、GitHub等8中图床。 除此之外，还可以使用坚果云等云存储工具作为网络存储来保存编写的文件，这样就不怕丢失了，还可以在手机端查看。 Markdown语法==注意：在编写Markdown语法时，要多注意空格和回车，否则无法生效== 标题#[空格]标题 123456# 一阶标题 或 Ctrl+1## 二阶标题 或 Ctrl+2### 三阶标题 或 Ctrl+3#### 四阶标题 或 Ctrl+4##### 五阶标题 或 Ctrl+5###### 六阶标题 或 Ctrl+6 字体加粗1**加粗内容** 或 快捷键Ctrl+B 高亮1==高亮== 下划线1&lt;u&gt;下划线的内容&lt;/u&gt; 或 Ctrl+U 斜体1*倾斜内容* 或 Ctrl+I 删除线1~~删除线的内容~~ 或 Alt+Shift+5 文本居中1&lt;center&gt;居中的文本内容&lt;/center&gt; 角标1x^2^ 上角标 H~2~O 下角标 自动生成目录1在顶部添加[toc] list有序1数字+英文小数点(.)+空格 list无序1+ 、- 、*、+空格 todoList-空格[空格]空格 12- [ ] 未勾选- [x] 勾选 table1234567Ctrl+T或使用markdown语法| Tables | Are | Cool ||----------|:-------------:|------:|| col 1 is | left-aligned | $1600 || col 2 is | centered | $12 || col 3 is | right-aligned | $1 | 其中----------或:----------为左对齐，:----------:为居中对齐，----------:为右对齐。 1234567891011121314151617181920212223也可以使用html&lt;table&gt; &lt;tr&gt; &lt;th&gt;Tables&lt;/th&gt; &lt;th&gt;Are&lt;/th&gt; &lt;th&gt;Cool&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;col 1 is&lt;/td&gt; &lt;td&gt;left-aligned&lt;/td&gt; &lt;td&gt;$1600&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;col 2 is&lt;/td&gt; &lt;td&gt;centered&lt;/td&gt; &lt;td&gt;$12&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;col 3 is&lt;/td&gt; &lt;td&gt;right-aligned&lt;/td&gt; &lt;td&gt;$1&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 插入图片12![标题](链接) 或 Ctrl+K也可将图片直接拖拽进来，自动生成链接 链接1[标题](链接 引用1&gt;+空格 角标12标号[^1][^1]:标号的含义 表情123:单词:如 :happy::arrow_down: 快捷键12345678Ctrl+1 一阶标题 Ctrl+2 二阶标题 Ctrl+3 三阶标题Ctrl+4 四阶标题 Ctrl+5 五阶标题 Ctrl+6 六阶标题Ctrl+B 字体加粗 Ctrl+I 字体倾斜 Ctrl+U 下划线Ctrl+Home 返回Typora顶部 Ctrl+End 返回Typora底部 Ctrl+T 创建表格Ctrl+L 选中某句话 Ctrl+D 选中某个单词 Ctrl+E 选中相同格式的文字Ctrl+K 创建超链接 Ctrl+F 搜索 Ctrl+H 搜索并替换Alt+Shift+5 删除线 Ctrl+Shift+I 插入图片 Ctrl+Shift+M 公式块Ctrl+Shift+Q 引用 Typroa支持的Markdown语法远不止这些，还支持数学公式、程序流程图、UML等的编写。]]></content>
      <categories>
        <category>Typora</category>
        <category>Markdown</category>
      </categories>
      <tags>
        <tag>Typora</tag>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Hexo搭建个人博客并部署到GitHub和coding.net(GitCafe)]]></title>
    <url>%2F2019%2F09%2F19%2F%E4%BD%BF%E7%94%A8Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%B9%B6%E9%83%A8%E7%BD%B2%E5%88%B0GitHub%E5%92%8Ccoding.net(GitCafe)%2F</url>
    <content type="text"><![CDATA[最近在学习Flink时看到了一个阿里大佬的个人博客（Jark’s Blog）觉得挺不错的，界面简洁、优雅，内容干货满满。即可以记录自己学到的知识和生活中的点点滴滴，又可以分享给其他小伙伴。于是自己也想搭一个，en~那就开始吧。 Hexo的安装Hexo是高效的静态站点生成框架，基于Node.js，通过它可以快速构建个人博客，并搭建到GitHub或coding.net供他人访问。 安装Node.jd和Git windows：分别从nodejs官网下载LTS版本和Git官网下载git，然后安装即可。 windows安装完git后可以直接在git bash中写linux命令 安装hexo 1npm install -g hexo 初始化项目 hexo init 自动创建hexo项目，然后执行hexo s --debug启动hexo服务，可在本地通过http://localhost:4000查看效果，--debug参数可以查看详细的日志，不是必须的 部署到GitHub和coding.net 创建一个和用户名相同的仓库，后面加上.github.io，即xxx.github.io 生成SSH并添加到GitHub 配置信息 git config --global user.name &quot;yourname&quot; git config --global user.email &quot;youremail&quot; 生成秘钥 ssh-keygen -t rsa -C &quot;youremail&quot; 将id_rsa.pub中的公钥（全部复制）添加到GitHub和coding.net上 GitHub：点击头像 -&gt; Settings -&gt; SSH and GPG keys coding.net：点击头像 -&gt; 个人设置 -&gt; SSH公钥 使用ssh -T git@github.com查看是否成功 修改配置文件 _config.yml 1234567# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: github: https://github.com/username/username.github.io,master gitcafe: https://e.coding.net/username/username.git,master 推送 使用npm install hexo-deployer-git --save安装hexo部署工具 执行下面两个命令，就可以把项目自动部署到 github和coding.net上 123hexo cleanhexo generatehexo deploy 其中 hexo clean清除之前生成的东西，也可以不加，hexo generate 生成静态文章，可以用 hexo g缩写，hexo deploy 部署文章，可以用hexo d缩写。 注意deploy时需要输入username和password 成功之后可以使用https://username.github.io/访问部署在GitHub上的博客，使用https://randomCode.coding-pages.com/访问部署在coding.net上的博客（注意username的修改，coding.net上的访问地址要到部署 -&gt; 静态网站中查看）。 Hexo的基本使用以执行下列命令来创建一篇新文章或者新的页面 1$ hexo new [layout] &lt;title&gt; layout：指定文章的布局，默认为 post 接下来就可以使用Markdown工具编写在myBlog\source\_posts下的文章了 查看Hexo的官方文档，说明很详细 使用NexT主题查看NexT的官方文档，说明很详细 在使用NexT主题后遇到设置语言不生效的问题 1language: zh-Hans // 这里设置语言 简体中文 把theme/next/languages/目录下的zh-CN.yml文件改成名字为zh-Hans.yml就可以了 参考文档5分钟搞定个人博客-hexo hexo史上最全搭建教程 Hexo博客优化之Next主题美化 Hexo主题（Next）美化、配置、优化这一篇就够了]]></content>
      <categories>
        <category>Hexo</category>
        <category>NexT</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>NexT</tag>
      </tags>
  </entry>
</search>
